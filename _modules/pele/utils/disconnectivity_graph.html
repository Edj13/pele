

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pele.utils.disconnectivity_graph &mdash; pele 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/scipy.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="pele 0.1 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">pele 0.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pele.utils.disconnectivity_graph</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">izip</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>

<span class="kn">from</span> <span class="nn">pele.landscape</span> <span class="kn">import</span> <span class="n">database2graph</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;DisconnectivityGraph&quot;</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">TreeLeastCommonAncestor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the least common ancestor to a set of trees&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trees</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_trees</span> <span class="o">=</span> <span class="n">trees</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># find all common ancestors</span>
        <span class="n">common_ancestors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_trees</span><span class="p">:</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">get_ancestors</span><span class="p">())</span>
            <span class="n">parents</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_ancestors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">common_ancestors</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># remove all elements that are not common</span>
                <span class="n">common_ancestors</span><span class="o">.</span><span class="n">intersection_update</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_ancestors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_ancestors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;the trees don&#39;t have any common ancestors&quot;</span><span class="p">)</span>
        
        <span class="c"># sort the common ancestors by the number of ancestors each has</span>
        <span class="n">common_ancestors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">common_ancestors</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_ancestors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">common_ancestors</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">get_ancestors</span><span class="p">())))</span>

        <span class="c"># the least common ancestor is the one with the most ancestors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">least_common_ancestor</span> <span class="o">=</span> <span class="n">common_ancestors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">least_common_ancestor</span>
    
    <span class="k">def</span> <span class="nf">get_all_paths_to_common_ancestor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return all the ancestors of all the input trees up to the least common ancestor&quot;&quot;&quot;</span>
        <span class="n">trees</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_trees</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_trees</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">get_ancestors</span><span class="p">():</span>
                <span class="n">trees</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">parent</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">least_common_ancestor</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">trees</span>
        
            
<span class="c">#            for tree in common_ancestors:</span>
<span class="c">#                for parent in tree.get_ancestors():</span>
<span class="c">#                    if parent in common_ancestors</span>
<span class="c">#            </span>
<span class="c">#        return iter(common_ancestors).next()</span>


<span class="k">class</span> <span class="nc">Tree</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a Tree graph</span>
<span class="sd">    </span>
<span class="sd">    Each member of this class is a node in a Tree.  The node can</span>
<span class="sd">    have many children, but only one parent.  If the node has no</span>
<span class="sd">    parents then it is the root node.  If the node has no children</span>
<span class="sd">    then it is a leaf.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subtrees</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
    
    <span class="k">def</span> <span class="nf">add_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">branch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;make branch a child of this tree&quot;&quot;&quot;</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">subtrees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">branch</span><span class="p">)</span>
        <span class="n">branch</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
    
    <span class="k">def</span> <span class="nf">make_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a new Tree which is a child of this Tree&quot;&quot;&quot;</span>
        <span class="n">newtree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subtrees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newtree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newtree</span>
    
    <span class="k">def</span> <span class="nf">get_subtrees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;get_subtrees() is deprecated. use get_branches() instead!&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_branches</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">get_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the list of branches of this tree&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtrees</span>
    
    <span class="k">def</span> <span class="nf">number_of_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the number of branches of this tree&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subtrees</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return true if this tree has no descendants&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_branches</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
    
    <span class="k">def</span> <span class="nf">number_of_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the number of leaves that are descendants of this Tree&quot;&quot;&quot;</span> 
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subtrees</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nleaves</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nleaves</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtrees</span><span class="p">:</span>
                <span class="n">nleaves</span> <span class="o">+=</span> <span class="n">tree</span><span class="o">.</span><span class="n">number_of_leaves</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">nleaves</span>
    
    <span class="k">def</span> <span class="nf">get_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a list of the leaves that are descendants of this Tree&quot;&quot;&quot;</span> 
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="n">leaves</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">leaves</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtrees</span><span class="p">:</span>
                <span class="n">leaves</span> <span class="o">+=</span> <span class="n">tree</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">leaves</span>
    
    <span class="k">def</span> <span class="nf">leaf_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;iterate through the leaves that are descendants of this Tree&quot;&quot;&quot;</span> 
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtrees</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">leaf_iterator</span><span class="p">():</span>
                    <span class="k">yield</span> <span class="n">leaf</span>
    
    <span class="k">def</span> <span class="nf">get_all_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;iterator over all subtrees, including self&quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_branches</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">branch</span><span class="o">.</span><span class="n">get_all_trees</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">subtree</span>

    <span class="k">def</span> <span class="nf">number_of_subtrees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ntot</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_branches</span><span class="p">():</span>
            <span class="n">ntot</span> <span class="o">+=</span> <span class="n">branch</span><span class="o">.</span><span class="n">number_of_subtrees</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ntot</span>
    
    <span class="k">def</span> <span class="nf">get_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;iterate over ancestors excluding self&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
            <span class="k">for</span> <span class="n">ancestor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">get_ancestors</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">ancestor</span>
            

<span class="k">class</span> <span class="nc">DGTree</span><span class="p">(</span><span class="n">Tree</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;add a few functions to Tree to make it specific to disconnectivity graph&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">contains_minimum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">min1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
    
    <span class="k">def</span> <span class="nf">get_minima</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">leaf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]</span>
    
    <span class="k">def</span> <span class="nf">get_one_minimum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a single minimum that is in this tree&quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s">&quot;_random_minimum&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_branches</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_one_minimum</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>
            <span class="k">return</span> <span class="n">m</span>
    
    <span class="k">def</span> <span class="nf">_test_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all_trees</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">tset</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;tree is touched twice&quot;</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">tset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">True</span>
        
<span class="k">class</span> <span class="nc">UnionFind</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">UnionFind</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">groups_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">c1</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_MakeTree</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;class to Make the disconnectivity graph tree</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    minima : list of Minimum objects</span>
<span class="sd">        the minima to contain in the disconnectivity graph</span>
<span class="sd">    transition_states : list of TransitionState objects</span>
<span class="sd">        the transition states to contain in the disconnectivity graph</span>
<span class="sd">    energy_levels : list of floats</span>
<span class="sd">        the energy levels at which to split the graph</span>
<span class="sd">    get_energy : callable</span>
<span class="sd">        a function which returns the energy of a transition state.  You can </span>
<span class="sd">        use this to redefine the `energy` of a transition state, e.g. for a </span>
<span class="sd">        free energy disconnectivity graph.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This algorithm starts from a completely disconnected graph and adds</span>
<span class="sd">    transition states one at a time, starting from the lowest energy transition</span>
<span class="sd">    state.  Connectivity is determined solely through labeling minima based on</span>
<span class="sd">    which cluster it&#39;s in.  If a new transition</span>
<span class="sd">    state connects two previously disconnected clusters, the clusters are</span>
<span class="sd">    joined to make one single cluster.  As the transition states are added</span>
<span class="sd">    (sorted in energy) the energy levels are reached one at a time.  At each</span>
<span class="sd">    level, the state of the connectivity of the graph is saved in tree graphs.</span>
<span class="sd">    </span>
<span class="sd">    This algorithm is very similar to kruskal&#39;s minimum spanning tree algorithm</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minima</span><span class="p">,</span> <span class="n">transition_states</span><span class="p">,</span> <span class="n">energy_levels</span><span class="p">,</span> <span class="n">get_energy</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minima</span> <span class="o">=</span> <span class="n">minima</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transition_states</span> <span class="o">=</span> <span class="n">transition_states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energy_levels</span> <span class="o">=</span> <span class="n">energy_levels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_energy</span> <span class="o">=</span> <span class="n">get_energy</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">union_find</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimum_to_leave</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">get_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the energy of the transition state&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_energy</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ts</span><span class="o">.</span><span class="n">energy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_energy</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_new_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;make a new leaf from minimum m&quot;&quot;&quot;</span>
        <span class="n">leaf</span> <span class="o">=</span> <span class="n">DGTree</span><span class="p">()</span>
        <span class="n">leaf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">minimum_to_leave</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">leaf</span>
        <span class="k">return</span> <span class="n">leaf</span>
        
    <span class="k">def</span> <span class="nf">make_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;make the disconnectivity tree&quot;&quot;&quot;</span>
        <span class="c"># make list of transition states sorted so that lower energies are to the right</span>
        <span class="n">tslist</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">ts</span><span class="p">:</span> <span class="n">ts</span><span class="o">.</span><span class="n">minimum1</span> <span class="o">!=</span> <span class="n">ts</span><span class="o">.</span><span class="n">minimum2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_states</span><span class="p">)</span>
        <span class="c"># remove duplicate entries and sort</span>
        <span class="n">tslist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">tslist</span><span class="p">))</span>
        <span class="n">tslist</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">ts</span><span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">get_energy</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transition_states</span> <span class="o">=</span> <span class="n">tslist</span> 

        <span class="n">trees</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c"># build the tree up starting at the lowest level</span>
        <span class="k">for</span> <span class="n">ilevel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energy_levels</span><span class="p">)):</span>
            <span class="n">trees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_next_level</span><span class="p">(</span><span class="n">ilevel</span><span class="p">,</span> <span class="n">trees</span><span class="p">)</span>

        <span class="c"># deal with any disconnected parts</span>
        <span class="n">energy_levels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_levels</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="n">trees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="n">DGTree</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">add_branch</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;ilevel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">energy_levels</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">de</span> <span class="o">=</span> <span class="n">energy_levels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">energy_levels</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;ethresh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">energy_levels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.</span><span class="o">*</span><span class="n">de</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;children_not_connected&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="bp">False</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">_test_tree</span><span class="p">()</span>
            <span class="k">print</span> <span class="s">&quot;tree test result&quot;</span><span class="p">,</span> <span class="n">res</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span>

    <span class="k">def</span> <span class="nf">_add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;add an edge between min1 and min2</span>
<span class="sd">        </span>
<span class="sd">        if min1 and min2 belong to different color groups, those groups</span>
<span class="sd">        will be set equal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_minima</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">min1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">union_find</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
            <span class="n">new_minima</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">union_find</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
            <span class="n">new_minima</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">union_find</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_minima</span>

    <span class="k">def</span> <span class="nf">_do_next_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ilevel</span><span class="p">,</span> <span class="n">previous_trees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;do the disconnectivity analysis for energy level ilevel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ethresh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_levels</span><span class="p">[</span><span class="n">ilevel</span><span class="p">]</span>
        
        <span class="c"># add the edges to the graph up to ethresh</span>
        <span class="n">tslist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_states</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">tslist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">tslist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_energy</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">ethresh</span><span class="p">:</span>
                <span class="k">break</span>
            
            <span class="n">new_minima</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_edge</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">minimum1</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">minimum2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">new_minima</span><span class="p">:</span>
                <span class="n">previous_trees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new_leaf</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
            
            <span class="c"># remove the transition state from the list</span>
            <span class="n">tslist</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        
        <span class="c"># make a new tree for every color (connected cluster)</span>
        <span class="n">newtrees</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">color_to_tree</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">union_find</span><span class="o">.</span><span class="n">groups_iter</span><span class="p">():</span>
            <span class="n">newtree</span> <span class="o">=</span> <span class="n">DGTree</span><span class="p">()</span>
            <span class="n">newtree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;ilevel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ilevel</span> 
            <span class="n">newtree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;ethresh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ethresh</span>
            <span class="n">newtrees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newtree</span><span class="p">)</span>
            <span class="n">color_to_tree</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">newtree</span>
        
        <span class="c"># determine parentage</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">previous_trees</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">get_one_minimum</span><span class="p">()</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">union_find</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">color_to_tree</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">number_of_branches</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># remove linear parentage.</span>
                <span class="n">subtree</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">)</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="n">parent</span><span class="o">.</span><span class="n">add_branch</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent</span><span class="o">.</span><span class="n">add_branch</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">newtrees</span>


<span class="k">class</span> <span class="nc">ColorDGraphByGroups</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;color the graph based on specified grouping of minima</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tree_graph: a DGTree object</span>
<span class="sd">        usually accessed by dgraph.tree_graph if dgraph is a </span>
<span class="sd">        DisconnectivityGraph object.</span>
<span class="sd">    groups : list</span>
<span class="sd">        list of groups of minima that should have the same color</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For each node, check all minima for which the node is a parent.</span>
<span class="sd">    If all minima are contained on one of the groups, the node </span>
<span class="sd">    will be coloured to represent that group.  </span>
<span class="sd">    If any minimum is not contained on one of the groups, the node</span>
<span class="sd">    is not coloured. </span>
<span class="sd">    If all minima are contained in groups but more than one group </span>
<span class="sd">    is represented, the node will be the colour of the last group listed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_graph</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_graph</span> <span class="o">=</span> <span class="n">tree_graph</span>
        
        <span class="c"># set the colors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_minimum_to_color</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_list_of_colors</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">),</span> <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">color</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">color_list</span><span class="p">,</span> <span class="n">groups</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">minimum</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_minimum_to_color</span><span class="p">[</span><span class="n">minimum</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_to_colors</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">get_list_of_colors_mpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a list of colors for the groups.  Use matplotlib colormap&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
        <span class="n">colormap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s">&quot;Dark2&quot;</span><span class="p">,</span> <span class="n">lut</span><span class="o">=</span><span class="n">number</span><span class="p">)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">colormap</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">number</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">colors</span>
    
    <span class="k">def</span> <span class="nf">parse_list_of_colors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">ColorConverter</span>
        <span class="n">cconvert</span> <span class="o">=</span> <span class="n">ColorConverter</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;the length of colors must be the number of groups&quot;</span><span class="p">)</span>
        <span class="n">rgbcolors</span> <span class="o">=</span> <span class="p">[</span><span class="n">cconvert</span><span class="o">.</span><span class="n">to_rgb</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">rgbcolors</span> 
        
         
    <span class="k">def</span> <span class="nf">get_list_of_colors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a list of colors for the groups&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_list_of_colors</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">colors</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">brewer2mpl</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;could not import brewer2mpl.&quot;</span>
            <span class="k">print</span> <span class="s">&quot;install package brewer2mpl for a nicer color scheme&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_list_of_colors_mpl</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">12</span><span class="p">:</span>
            <span class="n">bnumber</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">number</span><span class="p">)</span>
            <span class="n">bcolors</span> <span class="o">=</span> <span class="n">brewer2mpl</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="s">&quot;Dark2&quot;</span><span class="p">,</span> <span class="s">&quot;Qualitative&quot;</span><span class="p">,</span> <span class="n">bnumber</span><span class="p">)</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">bcolors</span><span class="o">.</span><span class="n">mpl_colors</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[:</span><span class="n">number</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_list_of_colors_mpl</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">colors</span>
    
    <span class="k">def</span> <span class="nf">minimum_to_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minimum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the color of the minimum, or None if not colored&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minimum_to_color</span><span class="p">[</span><span class="n">minimum</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
    
    <span class="k">def</span> <span class="nf">tree_get_colors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the color that this tree should be colored by&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_to_colors</span><span class="p">[</span><span class="n">tree</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_to_color</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">colors</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">colors</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">color</span><span class="p">])</span>    
                <span class="bp">self</span><span class="o">.</span><span class="n">_tree_to_colors</span><span class="p">[</span><span class="n">tree</span><span class="p">]</span> <span class="o">=</span> <span class="n">colors</span>
                <span class="k">return</span> <span class="n">colors</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">colors_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_get_colors</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span> <span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">get_branches</span><span class="p">()]</span>
                <span class="k">if</span> <span class="bp">None</span> <span class="ow">in</span> <span class="n">colors_list</span><span class="p">:</span>
                    <span class="n">colors</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">colors</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">g</span> <span class="k">for</span> <span class="n">colors1</span> <span class="ow">in</span> <span class="n">colors_list</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">colors1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tree_to_colors</span><span class="p">[</span><span class="n">tree</span><span class="p">]</span> <span class="o">=</span> <span class="n">colors</span>
                <span class="k">return</span> <span class="n">colors</span>
    
    <span class="k">def</span> <span class="nf">colors_to_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;if there are multiple colors for this tree, select which one to use</span>
<span class="sd">        </span>
<span class="sd">        select the color which is listed last in self.color_list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">color_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">color</span>       
            
    
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;main loop for the algorithm&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_graph</span><span class="o">.</span><span class="n">get_all_trees</span><span class="p">():</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_get_colors</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;colour&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors_to_color</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
    
<span class="k">class</span> <span class="nc">ColorDGraphByValue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;color a disconnectivity graph by values associated with minima (e.g. order parameter)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tree_graph: a DGTree object</span>
<span class="sd">        usually accessed by dgraph.tree_graph if dgraph is a </span>
<span class="sd">        DisconnectivityGraph object.</span>
<span class="sd">    minimum_to_value: callable</span>
<span class="sd">        A function that accepts a minimum and returns a float value.</span>
<span class="sd">        return None to indicate no color for this minimum</span>
<span class="sd">    colormap: callable, optional</span>
<span class="sd">        function which converts a float in (0,1) to a matplotlib color (RGB)</span>
<span class="sd">    normalize_values: bool</span>
<span class="sd">        if True the values will be normalized to fall between 0 and 1</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Each node in the graph will be colored according to the value of the </span>
<span class="sd">    child minimum with the largest value.  If any child minimum has value None</span>
<span class="sd">    then the node will not be colored</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_graph</span><span class="p">,</span> <span class="n">minimum_to_value</span><span class="p">,</span> <span class="n">colormap</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
                 <span class="n">normalize_values</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_graph</span> <span class="o">=</span> <span class="n">tree_graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimum_to_value</span> <span class="o">=</span> <span class="n">minimum_to_value</span>
        <span class="k">if</span> <span class="n">colormap</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s">&quot;winter&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span> <span class="o">=</span> <span class="n">colormap</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_to_value</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">normalize_values</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_to_value</span><span class="p">(</span><span class="n">leaf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">])</span> 
                      <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_graph</span><span class="o">.</span><span class="n">leaf_iterator</span><span class="p">()]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxval</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minval</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minval</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxval</span> <span class="o">=</span> <span class="bp">None</span>
    
    <span class="k">def</span> <span class="nf">resolve_multiple_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">None</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">value_to_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">minval</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">vnorm</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vnorm</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">minval</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxval</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">minval</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">colormap</span><span class="p">(</span><span class="n">vnorm</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">tree_get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the color that this tree should be colored by&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_to_value</span><span class="p">[</span><span class="n">tree</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_to_value</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tree_to_value</span><span class="p">[</span><span class="n">tree</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_get_value</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span> <span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">get_branches</span><span class="p">()]</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolve_multiple_values</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tree_to_value</span><span class="p">[</span><span class="n">tree</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">return</span> <span class="n">value</span>
    
            
    
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;main loop for the algorithm&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_graph</span><span class="o">.</span><span class="n">get_all_trees</span><span class="p">():</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_get_value</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;colour&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_to_color</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>    
            
    
    

<div class="viewcode-block" id="DisconnectivityGraph"><a class="viewcode-back" href="../../../generated/pele.utils.disconnectivity_graph.DisconnectivityGraph.html#pele.utils.disconnectivity_graph.DisconnectivityGraph">[docs]</a><span class="k">class</span> <span class="nc">DisconnectivityGraph</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    make a disconnectivity graph</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : a networkx graph</span>
<span class="sd">        a graph with Minimum objects as nodes and transition</span>
<span class="sd">        states defining the edges.  You can use the function</span>
<span class="sd">        database2graph() defined in this module to create this </span>
<span class="sd">        from a database.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; from pele.utils.disconnectivity_graph import database2graph</span>
<span class="sd">        &gt;&gt;&gt; graph = database2graph(database)</span>
<span class="sd">        &gt;&gt;&gt; dg = DisconnectivityGraph(graph)</span>
<span class="sd">         </span>
<span class="sd">    nlevels : int</span>
<span class="sd">        how many levels at which to bin the transition states</span>
<span class="sd">    Emax : float</span>
<span class="sd">        maximum energy for transition state cutoff.  Default</span>
<span class="sd">        is the maximum energy of all transition states.</span>

<span class="sd">    minima : list of Minima</span>
<span class="sd">        a list of minima to ensure are displayed in the graph.</span>
<span class="sd">        e.g. they will be displayed even if they&#39;re in a connected</span>
<span class="sd">        cluster smaller than smaller than subgraph_size</span>
<span class="sd">    subgraph_size : int</span>
<span class="sd">        if subgraph_size is not None then all disconnected graphs</span>
<span class="sd">        of size greater than subraph_size will be included.</span>

<span class="sd">    order_by_energy : bool</span>
<span class="sd">        order the subtrees by placing ones with lower energy closer</span>
<span class="sd">        to the center</span>
<span class="sd">    order_by_basin_size : bool</span>
<span class="sd">        order the subtrees by placing larger basins closer to the center</span>
<span class="sd">    center_gmin : bool</span>
<span class="sd">        when a node splits into its daughter</span>
<span class="sd">        nodes, the one containing the global minimum is always placed centrally</span>
<span class="sd">        (even if other nodes carry more minima). This does not guarantee that</span>
<span class="sd">        the global minimum is central in the overall diagram because other</span>
<span class="sd">        nodes may push the one containing the global minimum over to one side</span>
<span class="sd">    include_gmin : bool</span>
<span class="sd">        make sure to include the global minimum, even if it is not part of the</span>
<span class="sd">        main connected region</span>
<span class="sd">    node_offset : float</span>
<span class="sd">        offset between 0 and 1 for how to draw the angled lines.</span>
<span class="sd">        0 for no angle, draw horizontally out then vertically down.  1 for </span>
<span class="sd">        angled lines all the way to the next energy level        </span>
<span class="sd">    energy_attribute : string, optional</span>
<span class="sd">        attribute which contains energy. default is energy. This attribute can</span>
<span class="sd">        be used to generate free energy disconnectivity graphs</span>
<span class="sd">    order_by_value : callable, optional, `v = order_by_value(m)`</span>
<span class="sd">        If this function is passed the minima at each level will be sorted by this value</span>
<span class="sd">        with small values to the left.  A group of minima will be sorted according to the </span>
<span class="sd">        smallest value in the group.  </span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    ---------</span>
<span class="sd">    make_disconnectivity_graph.py :</span>
<span class="sd">        a script (in pele/scripts) to make the disconnectivity graph from the command line</span>
<span class="sd">    pele.storage.Database :</span>
<span class="sd">        The database format in which minima and transition states are stored in pele</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    These examples assume a Database with minima already exists</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; graph = database2graph(database)</span>
<span class="sd">    &gt;&gt;&gt; dg = DisconnectivityGraph(graph)</span>
<span class="sd">    &gt;&gt;&gt; dg.calculate()</span>
<span class="sd">    &gt;&gt;&gt; dg.plot()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">minima</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">nlevels</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">subgraph_size</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">order_by_energy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">order_by_basin_size</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">node_offset</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
                 <span class="n">center_gmin</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">include_gmin</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">energy_attribute</span><span class="o">=</span><span class="s">&quot;energy&quot;</span><span class="p">,</span>
                 <span class="n">order_by_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">=</span> <span class="n">nlevels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Emax</span> <span class="o">=</span> <span class="n">Emax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subgraph_size</span> <span class="o">=</span> <span class="n">subgraph_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_by_basin_size</span> <span class="o">=</span> <span class="n">order_by_basin_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_by_energy</span> <span class="o">=</span> <span class="n">order_by_energy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_gmin</span> <span class="o">=</span> <span class="n">center_gmin</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">gmin0</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energy_attribute</span> <span class="o">=</span> <span class="n">energy_attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_offset</span> <span class="o">=</span> <span class="n">node_offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span> <span class="o">=</span> <span class="n">order_by_value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_gmin</span><span class="p">:</span>
            <span class="n">include_gmin</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="n">minima</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">minima</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min0list</span> <span class="o">=</span> <span class="n">minima</span>
        <span class="k">if</span> <span class="n">include_gmin</span><span class="p">:</span>
            <span class="c">#find the minimum energy node</span>
            <span class="n">elist</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getEnergy</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="p">]</span>
            <span class="n">elist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">elist</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gmin0</span> <span class="o">=</span> <span class="n">elist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min0list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gmin0</span><span class="p">)</span>
<span class="c">#            print &quot;min0&quot;, self.min0.energy, self.min0._id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transition_states</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="s">&quot;ts&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_list</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_getEnergy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get the energy of a node &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_attribute</span><span class="p">)</span>
    
<div class="viewcode-block" id="DisconnectivityGraph.set_energy_levels"><a class="viewcode-back" href="../../../generated/pele.utils.disconnectivity_graph.DisconnectivityGraph.set_energy_levels.html#pele.utils.disconnectivity_graph.DisconnectivityGraph.set_energy_levels">[docs]</a>    <span class="k">def</span> <span class="nf">set_energy_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elevels</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; manually set the energy levels &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elevels</span> <span class="o">=</span> <span class="n">elevels</span>
        </div>
    <span class="k">def</span> <span class="nf">_getTS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the transition state object between two minima&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_states</span><span class="p">[(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_states</span><span class="p">[(</span><span class="n">min2</span><span class="p">,</span> <span class="n">min1</span><span class="p">)]</span>


    <span class="c">#############################################################</span>
    <span class="c"># functions for building the tree by splitting the graph into</span>
    <span class="c"># connected components at each level </span>
    <span class="c">#############################################################</span>


    <span class="k">def</span> <span class="nf">_connected_component_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        redefine the networkx version because they use deepcopy</span>
<span class="sd">        on the nodes and edges</span>
<span class="sd">        </span>
<span class="sd">        this was copied and only slightly modified from the original</span>
<span class="sd">        source</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">graph_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cc</span><span class="p">:</span>
            <span class="n">graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">graph_list</span>
    

    <span class="k">def</span> <span class="nf">_make_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">energy_levels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;make the disconnectivity graph tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">transition_states</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">&quot;ts&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">minima</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
        <span class="n">maketree</span> <span class="o">=</span> <span class="n">_MakeTree</span><span class="p">(</span><span class="n">minima</span><span class="p">,</span> <span class="n">transition_states</span><span class="p">,</span> <span class="n">energy_levels</span><span class="p">,</span> 
                             <span class="n">get_energy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_getEnergy</span><span class="p">)</span>
        <span class="n">trees</span> <span class="o">=</span> <span class="n">maketree</span><span class="o">.</span><span class="n">make_tree</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimum_to_leave</span> <span class="o">=</span> <span class="n">maketree</span><span class="o">.</span><span class="n">minimum_to_leave</span>
        <span class="k">return</span> <span class="n">trees</span>
        
    <span class="c">#################################################################</span>
    <span class="c"># These functions determine how to layout the tree on the x axis</span>
    <span class="c">#################################################################</span>

    <span class="k">def</span> <span class="nf">_recursive_layout_x_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">dx_per_min</span><span class="p">):</span>
<span class="c">#        nbranches = tree.number_of_branches()</span>
        <span class="n">nminima</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">number_of_leaves</span><span class="p">()</span>
        <span class="n">subtrees</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">get_branches</span><span class="p">()</span>
        <span class="n">subtrees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_trees</span><span class="p">(</span><span class="n">subtrees</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xmin</span> <span class="o">+</span> <span class="n">dx_per_min</span> <span class="o">*</span> <span class="n">nminima</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">xmin</span>
        <span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">subtrees</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_layout_x_axis</span><span class="p">(</span><span class="n">subtree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dx_per_min</span><span class="p">)</span>
            <span class="n">nminima_sub</span> <span class="o">=</span> <span class="n">subtree</span><span class="o">.</span><span class="n">number_of_leaves</span><span class="p">()</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="n">dx_per_min</span> <span class="o">*</span> <span class="n">nminima_sub</span>
  
    <span class="k">def</span> <span class="nf">_layout_x_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;determining the x position of the branches and leaves</span>
<span class="sd">        </span>
<span class="sd">        used in displaying the disconnectivity graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="mf">4.0</span>
        <span class="n">dx_per_min</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_layout_x_axis</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">dx_per_min</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_tree_get_minimum_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">emin</span><span class="o">=</span><span class="mf">1e100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return the minimum energy of all the leaves in the tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">([</span><span class="n">leaf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">energy</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()])</span>
        
    <span class="k">def</span> <span class="nf">_order_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        order a list of trees for printing</span>
<span class="sd">        </span>
<span class="sd">        This is the highest level function for ordering trees.  This, </span>
<span class="sd">        and functions called by this, will account for all the user options </span>
<span class="sd">        like center_gmin and order by energy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_trees_by_value</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_by_energy</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_trees_by_minimum_energy</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_trees_by_most_leaves</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_order_trees_by_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;order the trees by a value. smaller numbers to the left</span>
<span class="sd">        </span>
<span class="sd">        Each tree will take the smallest value of all its associated minima.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">get_min_val</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">leaf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">leaf_iterator</span><span class="p">()])</span>
        <span class="n">trees</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">get_min_val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trees</span>

    <span class="k">def</span> <span class="nf">_order_trees_final</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_value_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tree_value_list :</span>
<span class="sd">            a list of (value, tree) pairs where value is the object</span>
<span class="sd">            by which to sort the trees</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        treelist :</span>
<span class="sd">            a list of trees ordered with the lowest in the center</span>
<span class="sd">            and the others placed successively on the left and right</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mylist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tree_value_list</span><span class="p">)</span>
        <span class="n">neworder</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mylist</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">neworder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">neworder</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">neworder</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ensure_gmin_is_center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_value_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;ensure that the tree containing the global minimum has the lowest value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmin0</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">min0index</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tree_value_list</span><span class="p">)):</span>
            <span class="n">v</span><span class="p">,</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">tree_value_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmin0</span> <span class="ow">in</span> <span class="p">[</span> <span class="n">leaf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()]:</span>
                <span class="n">min0index</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">min0index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">minvalue</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">tree_value_list</span><span class="p">])</span>
            <span class="c">#replace the value with a lower one</span>
            <span class="c">#for the tree containing min0</span>
            <span class="n">newvalue</span> <span class="o">=</span> <span class="n">minvalue</span> <span class="o">-</span> <span class="mi">1</span> <span class="c">#this won&#39;t work for non number values</span>
            <span class="n">tree_value_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">newvalue</span><span class="p">,</span> <span class="n">tree_value_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> 
        <span class="k">return</span> <span class="n">tree_value_list</span> 

            
        

    <span class="k">def</span> <span class="nf">_order_trees_by_most_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;order list of trees by the number of leaves&quot;&quot;&quot;</span>
<span class="c">#        if self.center_gmin:</span>
<span class="c">#            return self._order_trees_by_most_leaves_and_global_min(trees)</span>
        <span class="n">mylist</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">number_of_leaves</span><span class="p">(),</span> <span class="n">tree</span><span class="p">)</span> <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_gmin</span><span class="p">:</span>
            <span class="n">mylist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_gmin_is_center</span><span class="p">(</span><span class="n">mylist</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_trees_final</span><span class="p">(</span><span class="n">mylist</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_order_trees_by_minimum_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        order trees with by the lowest energy minimum.  the global minimum</span>
<span class="sd">        goes in the center, with the remaining being placed alternating on the</span>
<span class="sd">        left and on the right.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mylist</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_get_minimum_energy</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="n">tree</span><span class="p">)</span> <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_trees_final</span><span class="p">(</span><span class="n">mylist</span><span class="p">)</span>
                        

    <span class="c">#######################################################################</span>
    <span class="c"># functions which return the line segments that make up the visual graph</span>
    <span class="c">#######################################################################</span>

    <span class="k">def</span> <span class="nf">_get_line_segment_single</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_segments</span><span class="p">,</span> <span class="n">line_colours</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">eoffset</span><span class="p">):</span>
        <span class="n">color_default</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># this is a top level tree.  Add a short decorative vertical line</span>
            <span class="k">if</span> <span class="s">&quot;children_not_connected&quot;</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="c"># this tree is simply a container, add the line to the subtrees</span>
                <span class="n">treelist</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">treelist</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree</span><span class="p">]</span>
            
            <span class="n">dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_levels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_levels</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">treelist</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;x&quot;</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;ethresh&quot;</span><span class="p">]</span>
                <span class="n">line_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(([</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">]))</span>
                <span class="n">line_colours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">color_default</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># add two line segments.  A vertical one to yhigh</span>
            <span class="c">#  ([x, x], [y, yhigh])</span>
            <span class="c"># and an angled one connecting yhigh with the parent</span>
            <span class="c">#  ([x, xparent], [yhigh, yparent])</span>
            <span class="n">xparent</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span>
            <span class="n">xself</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span>
            <span class="n">yparent</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;ethresh&quot;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">yself</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getEnergy</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">yself</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;ethresh&quot;</span><span class="p">]</span>
            
            <span class="c"># determine yhigh from eoffset</span>
            <span class="n">yhigh</span> <span class="o">=</span> <span class="n">yparent</span> <span class="o">-</span> <span class="n">eoffset</span>
            <span class="k">if</span> <span class="n">yhigh</span> <span class="o">&lt;=</span> <span class="n">yself</span><span class="p">:</span>
                <span class="n">draw_vertical</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">yhigh</span> <span class="o">=</span> <span class="n">yself</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">draw_vertical</span> <span class="o">=</span> <span class="bp">True</span>
            
            <span class="c"># determine the line color</span>
            <span class="k">try</span><span class="p">:</span> 
                <span class="n">color</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;colour&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="n">color_default</span>
            
            <span class="c"># draw vertical line</span>
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">draw_vertical</span><span class="p">:</span>
                <span class="c"># stop diagonal line earlier to avoid artifacts</span>
                <span class="c"># change the x position so that the angle of the line</span>
                <span class="c"># doesn&#39;t change</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="s">&quot;_x_updated&quot;</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                    <span class="n">dxdy</span> <span class="o">=</span> <span class="p">(</span><span class="n">xself</span> <span class="o">-</span> <span class="n">xparent</span><span class="p">)</span> <span class="o">/</span> <span class="n">eoffset</span>
                    <span class="n">xself</span> <span class="o">=</span> <span class="n">dxdy</span> <span class="o">*</span> <span class="p">(</span><span class="n">yparent</span> <span class="o">-</span> <span class="n">yself</span><span class="p">)</span> <span class="o">+</span> <span class="n">xparent</span>
                    <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xself</span>
                    <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;_x_updated&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="c">#add vertical line segment</span>
                <span class="n">line_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">([</span><span class="n">xself</span><span class="p">,</span><span class="n">xself</span><span class="p">],</span> <span class="p">[</span><span class="n">yself</span><span class="p">,</span> <span class="n">yhigh</span><span class="p">])</span> <span class="p">)</span>
                <span class="n">line_colours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
<span class="c">#                print &quot;coloring vertical line&quot;, tree</span>
            
            <span class="c"># draw the diagonal line</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">tree</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&quot;children_not_connected&quot;</span><span class="p">):</span>
                <span class="n">line_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">([</span><span class="n">xself</span><span class="p">,</span> <span class="n">xparent</span><span class="p">],</span> <span class="p">[</span><span class="n">yhigh</span><span class="p">,</span> <span class="n">yparent</span><span class="p">])</span> <span class="p">)</span>
                <span class="n">line_colours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_line_segment_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_segments</span><span class="p">,</span> <span class="n">line_colours</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">eoffset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        add the line segment connecting this tree to its parent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_line_segment_single</span><span class="p">(</span><span class="n">line_segments</span><span class="p">,</span> <span class="n">line_colours</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">eoffset</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">get_branches</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_line_segment_recursive</span><span class="p">(</span><span class="n">line_segments</span><span class="p">,</span> <span class="n">line_colours</span><span class="p">,</span> <span class="n">subtree</span><span class="p">,</span> <span class="n">eoffset</span><span class="p">)</span>

        
    <span class="k">def</span> <span class="nf">_get_line_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">eoffset</span><span class="o">=-</span><span class="mf">1.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get all the line segments for drawing the connection between </span>
<span class="sd">        each minimum to it&#39;s parent node.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        line_segments : list</span>
<span class="sd">            list of line segments.  each line segment has the form ((x1, x2), (y1, y2))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">line_segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">line_colours</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_line_segment_recursive</span><span class="p">(</span><span class="n">line_segments</span><span class="p">,</span> <span class="n">line_colours</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">eoffset</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">line_segments</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">line_colours</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">line_segments</span><span class="p">,</span> <span class="n">line_colours</span>
    
    
    <span class="c">##########################################################################</span>
    <span class="c"># functions for determining which minima to include in the </span>
    <span class="c"># disconnectivity graph</span>
    <span class="c">##########################################################################</span>
    
    <span class="k">def</span> <span class="nf">_remove_nodes_with_few_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">nmin</span><span class="p">):</span>
        <span class="n">rmlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nmin</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rmlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmin0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmin0</span> <span class="ow">in</span> <span class="n">rmlist</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;global minimum has&quot;</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gmin0</span><span class="p">),</span> <span class="s">&quot;edges, not showing in graph&quot;</span>
            <span class="k">print</span> <span class="s">&quot;removing&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rmlist</span><span class="p">),</span> <span class="s">&quot;minima from graph with fewer than&quot;</span><span class="p">,</span> <span class="n">nmin</span><span class="p">,</span> <span class="s">&quot;edges&quot;</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">rmlist</span><span class="p">:</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">graph</span>

    
    <span class="k">def</span> <span class="nf">_remove_high_energy_minima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">emax</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">emax</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">graph</span>
        <span class="n">rmlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getEnergy</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">emax</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rmlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;removing </span><span class="si">%d</span><span class="s"> nodes with energy higher than&quot;</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">rmlist</span><span class="p">),</span> <span class="n">emax</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">rmlist</span><span class="p">:</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">graph</span>

    <span class="k">def</span> <span class="nf">_remove_high_energy_transitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">emax</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">emax</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">graph</span>
        <span class="n">rmlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> \
                  <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getEnergy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getTS</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="n">emax</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rmlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;removing </span><span class="si">%d</span><span class="s"> edges with energy higher than&quot;</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">rmlist</span><span class="p">),</span> <span class="n">emax</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">rmlist</span><span class="p">:</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">graph</span>

    <span class="k">def</span> <span class="nf">_reduce_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">min0list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;determine how much of the graph to include in the disconnectivity graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">used_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c">#make sure we include the subgraph containing min0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">min0list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c">#use the biggest connected cluster</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span>
            <span class="n">used_nodes</span> <span class="o">+=</span> <span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c">#list is ordered by size of cluster</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">min0</span> <span class="ow">in</span> <span class="n">min0list</span><span class="p">:</span>
                <span class="n">used_nodes</span> <span class="o">+=</span> <span class="n">nx</span><span class="o">.</span><span class="n">node_connected_component</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">min0</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subgraph_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">node_lists</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">node_lists</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subgraph_size</span><span class="p">:</span>
                    <span class="n">used_nodes</span> <span class="o">+=</span> <span class="n">nodes</span>

        <span class="n">newgraph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">used_nodes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newgraph</span>

    <span class="c">##########################################################################</span>
    <span class="c"># general functions</span>
    <span class="c">##########################################################################</span>
    
    
<div class="viewcode-block" id="DisconnectivityGraph.get_minima_layout"><a class="viewcode-back" href="../../../generated/pele.utils.disconnectivity_graph.DisconnectivityGraph.get_minima_layout.html#pele.utils.disconnectivity_graph.DisconnectivityGraph.get_minima_layout">[docs]</a>    <span class="k">def</span> <span class="nf">get_minima_layout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return the x position of the minima        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">leaves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_graph</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()</span>
        <span class="n">minima</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">]</span>
        <span class="n">xpos</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;x&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">xpos</span><span class="p">,</span> <span class="n">minima</span>
    </div>
<div class="viewcode-block" id="DisconnectivityGraph.get_tree_layout"><a class="viewcode-back" href="../../../generated/pele.utils.disconnectivity_graph.DisconnectivityGraph.get_tree_layout.html#pele.utils.disconnectivity_graph.DisconnectivityGraph.get_tree_layout">[docs]</a>    <span class="k">def</span> <span class="nf">get_tree_layout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the x position of the trees</span>
<span class="sd">        &#39;&#39;&#39;</span> 
        <span class="nb">id</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_list</span><span class="p">)):</span>
            <span class="nb">id</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="n">l</span><span class="p">,</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_list</span><span class="p">[</span><span class="n">l</span><span class="p">]))]</span>
        <span class="n">x_pos</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_list</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">id</span><span class="p">]</span> 
        <span class="n">energies</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_list</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;ethresh&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">id</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">id</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="n">energies</span>
        </div>
    <span class="k">def</span> <span class="nf">_get_energy_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        combine input and the graph data to determine what the </span>
<span class="sd">        energy levels will be.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;elevels&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elevels</span>
        
        <span class="c">#define the energy levels</span>
        <span class="n">elist</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_getEnergy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getTS</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">))</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;there are no edges in the graph.  Is the global minimum connected?&quot;</span><span class="p">)</span>
        <span class="n">emin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">elist</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Emax</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">emax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">elist</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">emax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Emax</span>
        <span class="n">de</span> <span class="o">=</span> <span class="p">(</span><span class="n">emax</span> <span class="o">-</span> <span class="n">emin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c">#the upper edge of the bins</span>
        <span class="n">elower</span> <span class="o">=</span> <span class="p">[</span><span class="n">emin</span> <span class="o">+</span> <span class="n">de</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span><span class="p">)]</span>
        <span class="n">elevels</span> <span class="o">=</span> <span class="n">elower</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">emin</span> <span class="o">+</span> <span class="n">de</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">elower</span>

<div class="viewcode-block" id="DisconnectivityGraph.calculate"><a class="viewcode-back" href="../../../generated/pele.utils.disconnectivity_graph.DisconnectivityGraph.calculate.html#pele.utils.disconnectivity_graph.DisconnectivityGraph.calculate">[docs]</a>    <span class="k">def</span> <span class="nf">calculate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        do the calculations necessary to draw the diconnectivity graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>
        <span class="k">assert</span> <span class="n">graph</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;graph has no minima&quot;</span>
        <span class="k">assert</span> <span class="n">graph</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;graph has no transition states&quot;</span>
        
        <span class="c"># we start with applying the energy cutoff, otherwise reduce</span>
        <span class="c"># graph does not work as intended</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_high_energy_minima</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Emax</span><span class="p">)</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_high_energy_transitions</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Emax</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">graph</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;after applying Emax, graph has no minima&quot;</span>
        <span class="k">assert</span> <span class="n">graph</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;after applying Emax, graph has no minima&quot;</span> 
        
        <span class="c"># find a reduced graph with only those connected to min0</span>
<span class="c">#        nodes = nx.node_connected_component(self.graph, self.min0)</span>
<span class="c">#        self.graph = self.graph.subgraph(nodes)</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min0list</span><span class="p">)</span>
        
        <span class="c"># define the energy levels</span>
        <span class="n">elevels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_energy_levels</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energy_levels</span> <span class="o">=</span> <span class="n">elevels</span>
        
        <span class="c"># remove more nodes</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_high_energy_minima</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">elevels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_high_energy_transitions</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">elevels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_nodes_with_few_edges</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="k">assert</span> <span class="n">graph</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;after cleaning up the graph, graph has no minima&quot;</span>
        <span class="k">assert</span> <span class="n">graph</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;after cleaning up the graph, graph has no edges&quot;</span> 

        <span class="c"># make the tree graph defining the discontinuity of the minima</span>
        <span class="n">tree_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_tree</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">elevels</span><span class="p">)</span>
        
        <span class="c">#assign id to trees</span>
        <span class="c"># this is needed for coloring basins</span>
<span class="c">#        self._assign_id(tree_graph)</span>
        
        <span class="c">#layout the x positions of the minima and the nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layout_x_axis</span><span class="p">(</span><span class="n">tree_graph</span><span class="p">)</span>

        <span class="c">#get the line segments which will be drawn to define the graph</span>
        <span class="n">eoffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">elevels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">elevels</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_offset</span>  <span class="c">#this should be passable</span>
<span class="c">#        line_segments = self._get_line_segments(tree_graph, eoffset=eoffset)</span>
        
        
        <span class="bp">self</span><span class="o">.</span><span class="n">eoffset</span> <span class="o">=</span> <span class="n">eoffset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_graph</span> <span class="o">=</span> <span class="n">tree_graph</span>
<span class="c">#        self.line_segments = line_segments</span>

</div>
<div class="viewcode-block" id="DisconnectivityGraph.color_by_group"><a class="viewcode-back" href="../../../generated/pele.utils.disconnectivity_graph.DisconnectivityGraph.color_by_group.html#pele.utils.disconnectivity_graph.DisconnectivityGraph.color_by_group">[docs]</a>    <span class="k">def</span> <span class="nf">color_by_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;color the graph based on specified grouping of minima</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        groups : list</span>
<span class="sd">            list of groups of minima that should have the same color</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For each node, check all minima for which the node is a parent.</span>
<span class="sd">        If all minima are contained on one of the groups, the node </span>
<span class="sd">        will be coloured to represent that group.  </span>
<span class="sd">        If any minimum is not contained on one of the groups, the node</span>
<span class="sd">        is not coloured. </span>
<span class="sd">        If all minima are contained in groups but more than one group </span>
<span class="sd">        is represented, the node will be the colour of the last group listed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">colorer</span> <span class="o">=</span> <span class="n">ColorDGraphByGroups</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_graph</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">colorer</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="DisconnectivityGraph.color_by_value"><a class="viewcode-back" href="../../../generated/pele.utils.disconnectivity_graph.DisconnectivityGraph.color_by_value.html#pele.utils.disconnectivity_graph.DisconnectivityGraph.color_by_value">[docs]</a>    <span class="k">def</span> <span class="nf">color_by_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minimum_to_value</span><span class="p">,</span> <span class="n">colormap</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
                 <span class="n">normalize_values</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>        
        <span class="sd">&quot;&quot;&quot;color the graph by values associated with minima (e.g. order parameter)</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        minimum_to_value: callable</span>
<span class="sd">            A function that accepts a minimum and returns a float value.</span>
<span class="sd">            return None to indicate no color for this minimum</span>
<span class="sd">        colormap: callable, optional</span>
<span class="sd">            function which converts a float in (0,1) to a matplotlib color (RGB)</span>
<span class="sd">        normalize_values: bool</span>
<span class="sd">            if True the values will be normalized to fall between 0 and 1</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Each node in the graph will be colored according to the value of the </span>
<span class="sd">        child minimum with the largest value.  If any child minimum has value None</span>
<span class="sd">        then the node will not be colored</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">colorer</span> <span class="o">=</span> <span class="n">ColorDGraphByValue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_graph</span><span class="p">,</span> <span class="n">minimum_to_value</span><span class="p">,</span>
                                     <span class="n">colormap</span><span class="o">=</span><span class="n">colormap</span><span class="p">,</span> 
                                     <span class="n">normalize_values</span><span class="o">=</span><span class="n">normalize_values</span><span class="p">)</span>
        <span class="n">colorer</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="DisconnectivityGraph.draw_minima"><a class="viewcode-back" href="../../../generated/pele.utils.disconnectivity_graph.DisconnectivityGraph.draw_minima.html#pele.utils.disconnectivity_graph.DisconnectivityGraph.draw_minima">[docs]</a>    <span class="k">def</span> <span class="nf">draw_minima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minima</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;draw a specified list of minima as points</span>
<span class="sd">        </span>
<span class="sd">        minima : list of minima</span>
<span class="sd">        axes : matlplotlib axes</span>
<span class="sd">            Draw them on these axes.  If None, use self.axes.</span>
<span class="sd">        kwargs : kwargs</span>
<span class="sd">            additional keyword arguments will be passed to matplolib.Axes.scatter().</span>
<span class="sd">            Use this to specify how to draw the points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
        
        <span class="k">if</span> <span class="s">&quot;marker&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s">&quot;marker&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;o&quot;</span>

        <span class="n">xpos</span><span class="p">,</span> <span class="n">minlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_minima_layout</span><span class="p">()</span>
        <span class="n">m2dist</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">izip</span><span class="p">(</span><span class="n">minlist</span><span class="p">,</span> <span class="n">xpos</span><span class="p">)))</span>
                
        <span class="n">minima</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">minima</span><span class="p">)</span>
        <span class="n">xpos</span> <span class="o">=</span> <span class="p">[</span><span class="n">m2dist</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">minima</span><span class="p">]</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">energy</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">minima</span><span class="p">]</span>

        <span class="n">axes</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xpos</span><span class="p">,</span> <span class="n">energies</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="DisconnectivityGraph.plot"><a class="viewcode-back" href="../../../generated/pele.utils.disconnectivity_graph.DisconnectivityGraph.plot.html#pele.utils.disconnectivity_graph.DisconnectivityGraph.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show_minima</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">show_trees</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
             <span class="n">title</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;draw the disconnectivity graph using matplotlib</span>
<span class="sd">        </span>
<span class="sd">        don&#39;t forget to call calculate() first</span>
<span class="sd">        </span>
<span class="sd">        also, you must call pyplot.show() to actually see the plot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">LineCollection</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">line_segments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_colours</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_line_segments</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_graph</span><span class="p">,</span> <span class="n">eoffset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eoffset</span><span class="p">)</span>

        <span class="c"># get the axes object        </span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s">&#39;white&#39;</span><span class="p">)</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">adjustable</span><span class="o">=</span><span class="s">&#39;box&#39;</span><span class="p">)</span>

        <span class="c">#set up how the figure should look</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s">&#39;out&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">tick_left</span><span class="p">()</span>
        <span class="c"># make the borders a bit prettier</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s">&#39;black&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s">&#39;none&#39;</span><span class="p">)</span>
<span class="c">#        plt.box(on=True)</span>

        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

        <span class="c">#draw the minima as points</span>
        <span class="k">if</span> <span class="n">show_minima</span><span class="p">:</span> 
            <span class="n">xpos</span><span class="p">,</span> <span class="n">minima</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_minima_layout</span><span class="p">()</span>
            <span class="n">energies</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">energy</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">minima</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xpos</span><span class="p">,</span> <span class="n">energies</span><span class="p">,</span> <span class="s">&#39;o&#39;</span><span class="p">)</span>
        
        <span class="c"># draw the line segments </span>
        <span class="c"># use LineCollection because it&#39;s much faster than drawing the lines individually </span>
        <span class="n">linecollection</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">([</span> <span class="p">[(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_segments</span><span class="p">])</span>
        <span class="n">linecollection</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="n">linewidth</span><span class="p">)</span>
        <span class="n">linecollection</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_colours</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">linecollection</span><span class="p">)</span>
        
        
        <span class="c"># scale the axes appropriately</span>
        <span class="c"># note: do not call ax.relim().  As of matplotlib version 1.3</span>
        <span class="c"># ax.relim() does not take Collections into account so it does</span>
        <span class="c"># not compute the limits correctly.  ax.autoscale_view() seems to work just fine</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">scalex</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">scaley</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">tight</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ybound</span><span class="p">(</span><span class="n">upper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Emax</span><span class="p">)</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xmin</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">xmax</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span>
        
        <span class="c"># remove xtics</span>
        <span class="c"># note: the xticks are removed after ax.autoscale_view() is called.</span>
        <span class="c"># If it is the other way around the lines are too close the image border          </span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="n">ax</span>
        </div>
<div class="viewcode-block" id="DisconnectivityGraph.label_minima"><a class="viewcode-back" href="../../../generated/pele.utils.disconnectivity_graph.DisconnectivityGraph.label_minima.html#pele.utils.disconnectivity_graph.DisconnectivityGraph.label_minima">[docs]</a>    <span class="k">def</span> <span class="nf">label_minima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minima_labels</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
                     <span class="n">rotation</span><span class="o">=</span><span class="mf">60.</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;label the specified minima</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        minima_labels: dict</span>
<span class="sd">            dictionary with minima as keys and labels as values.</span>
<span class="sd">            i.e. label = minima_labels[minimum]</span>
<span class="sd">        axes: matplotlib axis object, optional</span>
<span class="sd">            The axes we are working on</span>
<span class="sd">        rotation: float</span>
<span class="sd">            angle (in degrees) of how much to rotate the text</span>
<span class="sd">        kwargs: kwargs</span>
<span class="sd">            additional keyword arguments are passed on to matplotlib </span>
<span class="sd">            ax.set_xticklabels()</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        if the labels are outside of the figure bounding box you can fix it with</span>
<span class="sd">        plt.tight_layout() or fig.tight_layout() </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;you must call plot() before label_minima()&quot;</span>
                <span class="k">raise</span>
        <span class="n">leaves</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">leaf</span><span class="p">:</span> <span class="n">leaf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">minima_labels</span><span class="p">,</span> 
                        <span class="bp">self</span><span class="o">.</span><span class="n">tree_graph</span><span class="o">.</span><span class="n">leaf_iterator</span><span class="p">())</span>
        <span class="n">xpos</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;x&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">minima_labels</span><span class="p">[</span><span class="n">leaf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;minimum&quot;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">xpos</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="n">rotation</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="c">#         rescale = True</span>
<span class="c">#         if rescale:</span>
<span class="c">#             import matplotlib.pyplot as plt</span>
<span class="c">#             plt.tight_layout()</span>
 
    </div>
<div class="viewcode-block" id="DisconnectivityGraph.show"><a class="viewcode-back" href="../../../generated/pele.utils.disconnectivity_graph.DisconnectivityGraph.show.html#pele.utils.disconnectivity_graph.DisconnectivityGraph.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;simple wrapper for matplotlib.pyplot.show()&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span>
        <span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
<div class="viewcode-block" id="DisconnectivityGraph.savefig"><a class="viewcode-back" href="../../../generated/pele.utils.disconnectivity_graph.DisconnectivityGraph.savefig.html#pele.utils.disconnectivity_graph.DisconnectivityGraph.savefig">[docs]</a>    <span class="k">def</span> <span class="nf">savefig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;simple wrapper for matplotlib.pyplot.savefig()&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span>
        <span class="n">pyplot</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    </div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">pele 0.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Victor Rühle, Jacob Stevenson.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>